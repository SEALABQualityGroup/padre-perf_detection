operation UML!Lifeline getIndexReceiveMOS(message : UML!Message) : MessageOccuranceSpecification{
	//TODO
}

operation UML!Lifeline getBESInitializedBy(op : Operation) : BehaviorExecutionSpecification {

	return BehaviorExecutionSpecification.allInstances->selectOne(
		bes : BehaviorExecutionSpecification | 
			bes.getCovereds()->first() == self and 
				bes.getStart() == op.getMessageIn(self.getInteraction()).getReceiveEvent()		
	);
	
}

operation UML!Lifeline removeInteractionFragment(mes : InteractionFragment){
	self.getCoveredBys().remove(mes);
}


operation UML!Lifeline getNextIncomingMessageStartingFrom() : Sequence (UML!Message){
	return Message.allInstances->select(
		mes : UML!Message | self.getCoveredBys()->exists(mes.getReceiveEvent()) 
	);
}

operation UML!Lifeline getBESStartedBy(mos : MessageOccurrenceSpecification) : BehaviorExecutionSpecification{
	return self.getCoveredBys()->selectOne(
		iterator : InteractionFragment | iterator.isTypeOf(BehaviorExecutionSpecification) and iterator.getStart() == mos
	);
}

operation UML!Lifeline removeCovered(fragment : InteractionFragment){
	self.getCoveredBys().remove(fragment);
}

operation UML!Lifeline removeMsg(msg : UML!Message){

	var mosReceive = msg.getReceiveEvent();
	var bes = msg.getBES();
	var eos = msg.getEOS();

	self.getCoveredBys().remove(mosReceive);
	self.getCoveredBys().remove(bes);
	self.getCoveredBys().remove(eos);
}

// OK BUT CONSIDERS ALL MESSAGES (EVEN THE ONES WITHOUT GaAcqStep)
operation UML!Lifeline getIncomingMessages() : Map{
	var messages : Sequence(UML!Message) = new Sequence(UML!Message); 
	var map : Map(Interaction, Sequence(UML!Message));
	var interactions = self.getInteractions();
	if(interactions.notEmpty()){
		for(int in interactions ){
			messages.addAll(int.getMessages());
			map.put(int, messages->select(mes : UML!Message | mes.getReceiveEvent().getCovereds()->first().getRepresents().getType() == self.getRepresents().getType() and mes.notReturn()));
			//messages->select(mes : UML!Message | mes.getReceiveEvent().getCovereds()->first().getRepresents().getType() == self.getRepresents().getType() and mes.notReturn()).asList();
		}
	}
	return map;
}

operation UML!Lifeline getInteractionUses() : Sequence(UML!InteractionUse){
	
	return self.getCoveredBys()->select(iterator | iterator.isTypeOf(UML!InteractionUse)).asSequence();
	
}

operation UML!Lifeline getInteractions() : Sequence(UML!Interaction){
	var interactions : Sequence(UML!Interaction) = new Sequence(UML!Interaction);
	
	var interUses = self.getInteractionUses();
	
	for(interUse in interUses){
		interactions.add(interUse.getRefersTo());
	}
	
	interactions.add(self.getInteraction());
	
	return interactions;
}


// OK BUT CONSIDERS ALL MESSAGES (EVEN THE ONES WITHOUT GaAcqStep)
operation UML!Lifeline getOutgoingMessages() : Map{
	var messages : Sequence(UML!Message) = new Sequence(UML!Message); 
	var map : Map(Interaction, Sequence(UML!Message));
	var interactions = self.getInteractions();
	if(interactions.notEmpty()){
		for(int in interactions ){
			messages.addAll(int.getMessages());
			map.put(int, messages->select(mes : UML!Message | mes.getSendEvent().getCovereds()->first().getRepresents().getType() == self.getRepresents().getType() and mes.notReturn()));
			//messages->select(mes : Message | mes.getReceiveEvent().getCovereds()->first().getRepresents().getType() == self.getRepresents().getType() and mes.notReturn()).asList();
		}
	}
	return map;
}

/*operation UML!Lifeline getOutgoingMessages() : Sequence(Message){
	
	var messages : Sequence(Message) = new Sequence(Message); 
	
	var interactions = self.getInteractions();
	
	if(interactions.notEmpty()){
		for(int in interactions ){
			messages.addAll(int.getMessages());
		}
	}
	
	return messages->select(mes : Message | mes.getSendEvent().getCovereds()->first().getRepresents().getType() == self.getRepresents().getType() and mes.notReturn()).asSequence();
}*/

operation UML!Lifeline getNextIncomingMessage(mes : UML!Message) : UML!Message{

	var incomingMes = self.getIncomingMessages();
	
	for (m in incomingMes){
		if( m.receiveEvent.namespace.getIndexOf(m.receiveEvent) > mes.receiveEvent.namespace.getIndexOf(mes.receiveEvent) ){
			return m;
		}
	}
	return null;
} 

operation UML!Lifeline getNextOutgoingMessage(mes : UML!Message) : UML!Message{
	var outgoingMes = self.getOutgoingMessages();
	
	for (m in outgoingMes){
		if( self.getInteraction().getIndexOf(m.sendEvent) > self.getInteraction().getIndexOf(mes.sendEvent) )
			return m;
	}
	return null;
} 

operation UML!Lifeline getBESes() : Sequence(BehaviorExecutionSpecification){
	return self.getCoveredBys()->select(cov | cov.isTypeOf(BehaviorExecutionSpecification)).asSequence();
}
