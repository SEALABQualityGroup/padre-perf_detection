//Remove a Component

//Libraries
import "../evl/library/artifact.eol";
import "../evl/library/association.eol";
import "../evl/library/classifier.eol";
import "../evl/library/component.eol";
import "../evl/library/element.eol";
import "../evl/library/interaction.eol";
import "../evl/library/interactionFragment.eol";
import "../evl/library/interactionOperand.eol";
import "../evl/library/combinedFragment.eol";
import "../evl/library/interface.eol";
import "../evl/library/lifeline.eol";
import "../evl/library/manifestation.eol";
import "../evl/library/message.eol";
import "../evl/library/node.eol";
import "../evl/library/operation.eol";
import "../evl/library/package.eol";
//HELPER
import "../evl/library/HELPER.eol";

//Component to be removed
var target = Component.all->selectOne(c | c.getName() == targetComponentName);

if(target.isUndefined())
	throw "[ERROR]: Component " + targetComponentName + " is undefined";

//Given Lifeline move everything in component and remove empty entities 
for (lf : Lifeline in target.getLifelines()){
	var messageMap : Map = lf.getIncomingMessages();
	var listOfMessages = messageMap.values().first();
	
	var seenOperations : Set;
	
	for(messageInUse: Message in listOfMessages ){
		var op : Operation = messageInUse.getSignature();
		
		if(not seenOperations.includes(messageInUse.getInteraction().getName()+"_"+op.getName())){
			seenOperations.add(messageInUse.getInteraction().getName()+"_"+op.getName());
				
			// Recupera Component dove muovere OP
			var senderLf : Lifeline = messageInUse.getSendEvent().getCovered();
			var senderComponent: Component;
			if (senderLf.getRepresents().getType().isKindOf(Component)){
				 senderComponent = senderLf.getRepresents().getType();
			}
			
			// Se il senderLf Ã¨ un Attore Controllo prima se op viene utilizzata da altre lifeline,
			// se non trovo lifeline prendo qualsiasi altro componente (prima controllo interaction , 
			// se interaction non soddisfacente prendo dalla collezione di componenti generale)
			if(senderLf.getRepresents().getType().isKindOf(Actor)){
				var messageOpOwned : Sequence = op.getAllOwnMessages();
				for(msgInUse in messageOpOwned){
					var lifelineInUse : Lifeline =  msgInUse.getSendEvent().getCovered();
					if( lifelineInUse <> senderLf ){
						if (lifelineInUse.getRepresents().getType().isKindOf(Component)){
							senderComponent = lifelineInUse.getRepresents().getType();
							break;
						}
					}
				}
				
				if(senderComponent.isUndefined()){
					var interactionInUse: Interaction = messageOpOwned.first().getInteraction();
					var lifelineSequence : Sequence = Lifeline.allInstances->select(lf | lf.namespace == interactionInUse);
					for (lifelineInUse in lifelineSequence){
						if(lifelineInUse.getRepresents().getType().isKindOf(Component)){
							var safeComponent : Component =  lifelineInUse.getRepresents().getType();
							if( safeComponent <> target ){
								senderComponent = safeComponent;
								break;
							}
						}
					}
					if (senderComponent.isUndefined()){
						var safeComponent : Component = Component.all().first();
						if (safeComponent <> target){
							senderComponent = safeComponent;					
						}
					}
				}
			}
			// move the operation
			if(not senderComponent.isUndefined()){
				senderComponent.moveOperation(op);
				op.dynamicFixing(target);
			}
		}			
	}
	lf.destroy();
}


// Clean Deployment diagram
var nodesToDestroy : Sequence = target.getNodes();
for(n : Node in nodesToDestroy){
	for (a: Artifact in n.getArtifact() ){
		a.destroy();
	}
	var propertyToDestroy : Sequence ;
	for (cp in n.getCommunicationPaths()){
		var memberEnds = cp.getMemberEnds();
		for(property : Property in memberEnds){
			if(property.getType == n){
				propertyToDestroy.add(property);				
			}
		}
		cp.destroy();
	}			
	for(property: Property in propertyToDestroy){
		property.destroy();
	}
	n.destroy();
}



// Destroy component
target.destroy();
"Remove Component Done".println();
